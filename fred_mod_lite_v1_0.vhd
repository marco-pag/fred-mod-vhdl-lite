-------------------------------------------------------------------------------
--
-- Fred for Linux. Experimental support.
-- VHDL AXI lite stub for HLS-like Fred modules
-- AXI master orginal stub generated by IP integrator
-- 
-------------------------------------------------------------------------------
-- 
-- Copyright (C) 2019, Marco Pagani, ReTiS Lab.
-- <marco.pag(at)outlook.com>
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fred_mod_lite_v1_0 is
	generic (
    -- Parameters of Axi Slave Bus Interface
    C_S00_AXI_DATA_WIDTH	: integer	:= 32;
    C_S00_AXI_ADDR_WIDTH	: integer	:= 7;
    
    -- Parameters of Axi Master Bus Interface
    C_M00_AXI_ADDR_WIDTH	: integer	:= 32;
    C_M00_AXI_DATA_WIDTH	: integer	:= 32
	);
	port (
    -- Common signals
    interrupt : out std_logic;
    ap_clk	  : in std_logic;
    ap_rst_n  : in std_logic;

    -- Ports of Axi Slave Bus Interface
    --s_axi_ctrl_aclk	: in std_logic;
    --s_axi_ctrl_aresetn	: in std_logic;
    s_axi_ctrl_bus_awaddr	: in std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
    --s_axi_ctrl_bus_awprot	: in std_logic_vector(2 downto 0);
    s_axi_ctrl_bus_awvalid	: in std_logic;
    s_axi_ctrl_bus_awready	: out std_logic;
    s_axi_ctrl_bus_wdata	: in std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
    s_axi_ctrl_bus_wstrb	: in std_logic_vector((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
    s_axi_ctrl_bus_wvalid	: in std_logic;
    s_axi_ctrl_bus_wready	: out std_logic;
    s_axi_ctrl_bus_bresp	: out std_logic_vector(1 downto 0);
    s_axi_ctrl_bus_bvalid	: out std_logic;
    s_axi_ctrl_bus_bready	: in std_logic;
    s_axi_ctrl_bus_araddr	: in std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
    --s_axi_ctrl_bus_arprot	: in std_logic_vector(2 downto 0);
    s_axi_ctrl_bus_arvalid	: in std_logic;
    s_axi_ctrl_bus_arready	: out std_logic;
    s_axi_ctrl_bus_rdata	: out std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
    s_axi_ctrl_bus_rresp	: out std_logic_vector(1 downto 0);
    s_axi_ctrl_bus_rvalid	: out std_logic;
    s_axi_ctrl_bus_rready	: in std_logic;

    -- Ports of Axi Master Bus Interface
    --m_axi_mem_aclk	: in std_logic;
    --m_axi_mem_aresetn	: in std_logic;
    m_axi_mem_bus_awaddr	: out std_logic_vector(C_M00_AXI_ADDR_WIDTH-1 downto 0);
    m_axi_mem_bus_awprot	: out std_logic_vector(2 downto 0);
    m_axi_mem_bus_awvalid	: out std_logic;
    m_axi_mem_bus_awready	: in std_logic;
    m_axi_mem_bus_wdata 	:  out std_logic_vector(C_M00_AXI_DATA_WIDTH-1 downto 0);
    m_axi_mem_bus_wstrb	    : out std_logic_vector(C_M00_AXI_DATA_WIDTH/8-1 downto 0);
    m_axi_mem_bus_wvalid	: out std_logic;
    m_axi_mem_bus_wready	: in std_logic;
    m_axi_mem_bus_bresp	    : in std_logic_vector(1 downto 0);
    m_axi_mem_bus_bvalid	: in std_logic;
    m_axi_mem_bus_bready	: out std_logic;
    m_axi_mem_bus_araddr	: out std_logic_vector(C_M00_AXI_ADDR_WIDTH-1 downto 0);
    m_axi_mem_bus_arprot	: out std_logic_vector(2 downto 0);
    m_axi_mem_bus_arvalid	: out std_logic;
    m_axi_mem_bus_arready	: in std_logic;
    m_axi_mem_bus_rdata	    : in std_logic_vector(C_M00_AXI_DATA_WIDTH-1 downto 0);
    m_axi_mem_bus_rresp 	: in std_logic_vector(1 downto 0);
    m_axi_mem_bus_rvalid	: in std_logic;
    m_axi_mem_bus_rready	: out std_logic
	);
end fred_mod_lite_v1_0;

architecture arch_imp of fred_mod_lite_v1_0 is

	component fred_mod_ctrl_bus_s_axi is
    generic (
      C_S_AXI_ADDR_WIDTH    : INTEGER := 7;
      C_S_AXI_DATA_WIDTH    : INTEGER := 32
    );
    port (
      -- axi4 lite slave signals
      ACLK                  :in   STD_LOGIC;
      ARESET                :in   STD_LOGIC;
      ACLK_EN               :in   STD_LOGIC;
      AWADDR                :in   STD_LOGIC_VECTOR(C_S_AXI_ADDR_WIDTH-1 downto 0);
      AWVALID               :in   STD_LOGIC;
      AWREADY               :out  STD_LOGIC;
      WDATA                 :in   STD_LOGIC_VECTOR(C_S_AXI_DATA_WIDTH-1 downto 0);
      WSTRB                 :in   STD_LOGIC_VECTOR(C_S_AXI_DATA_WIDTH/8-1 downto 0);
      WVALID                :in   STD_LOGIC;
      WREADY                :out  STD_LOGIC;
      BRESP                 :out  STD_LOGIC_VECTOR(1 downto 0);
      BVALID                :out  STD_LOGIC;
      BREADY                :in   STD_LOGIC;
      ARADDR                :in   STD_LOGIC_VECTOR(C_S_AXI_ADDR_WIDTH-1 downto 0);
      ARVALID               :in   STD_LOGIC;
      ARREADY               :out  STD_LOGIC;
      RDATA                 :out  STD_LOGIC_VECTOR(C_S_AXI_DATA_WIDTH-1 downto 0);
      RRESP                 :out  STD_LOGIC_VECTOR(1 downto 0);
      RVALID                :out  STD_LOGIC;
      RREADY                :in   STD_LOGIC;
      interrupt             :out  STD_LOGIC;
      -- user signals
      ap_start              :out  STD_LOGIC;
      ap_done               :in   STD_LOGIC;
      ap_ready              :in   STD_LOGIC;
      ap_idle               :in   STD_LOGIC;
      id                    :in   STD_LOGIC_VECTOR(31 downto 0);
      id_ap_vld             :in   STD_LOGIC;
      args_address0         :in   STD_LOGIC_VECTOR(2 downto 0);
      args_ce0              :in   STD_LOGIC;
      args_q0               :out  STD_LOGIC_VECTOR(31 downto 0);
      mem_in                :out  STD_LOGIC_VECTOR(31 downto 0);
      mem_out               :out  STD_LOGIC_VECTOR(31 downto 0)
    );
	end component;

  component fred_mod_lite_v1_0_M00_AXI is
    generic (
      C_M_AXI_ADDR_WIDTH	: integer	:= 32;
      C_M_AXI_DATA_WIDTH	: integer	:= 32
    );
    port (
      IW_EXEC : in std_logic;
      IW_DONE : out std_logic;
      IW_ADDR  : in std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      IW_DATA  : in std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);

      IR_EXEC : in std_logic;
      IR_DONE : out std_logic;
      IR_ADDR  : in std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      IR_DATA  : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);

      M_AXI_ACLK	: in std_logic;
      M_AXI_ARESETN	: in std_logic;
      M_AXI_AWADDR	: out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      M_AXI_AWPROT	: out std_logic_vector(2 downto 0);
      M_AXI_AWVALID	: out std_logic;
      M_AXI_AWREADY	: in std_logic;
      M_AXI_WDATA	: out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
      M_AXI_WSTRB	: out std_logic_vector(C_M_AXI_DATA_WIDTH/8-1 downto 0);
      M_AXI_WVALID	: out std_logic;
      M_AXI_WREADY	: in std_logic;
      M_AXI_BRESP	: in std_logic_vector(1 downto 0);
      M_AXI_BVALID	: in std_logic;
      M_AXI_BREADY	: out std_logic;
      M_AXI_ARADDR	: out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      M_AXI_ARPROT	: out std_logic_vector(2 downto 0);
      M_AXI_ARVALID	: out std_logic;
      M_AXI_ARREADY	: in std_logic;
      M_AXI_RDATA	: in std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
      M_AXI_RRESP	: in std_logic_vector(1 downto 0);
      M_AXI_RVALID	: in std_logic;
      M_AXI_RREADY	: out std_logic
    );
  end component;
  
  component fred_mod_lite_v1_0_core is
    generic (
      C_S_AXI_ADDR_WIDTH	: integer	:= 32;
      C_S_AXI_DATA_WIDTH	: integer	:= 32;
      C_M_AXI_ADDR_WIDTH	: integer	:= 32;
      C_M_AXI_DATA_WIDTH	: integer	:= 32
    );
    port (
      aclk                  : in   std_logic;
      aresetn               : in   std_logic;

      -- AXI slaver internal control signals
      -- mem_in and mem_out are not used by FRED (HLS limitation)
      ap_start              : in   std_logic;
      ap_done               : out  std_logic;
      ap_ready              : out  std_logic;
      ap_idle               : out  std_logic;
      id                    : out  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      id_ap_vld             : out  std_logic;
      args_address0         : out  std_logic_vector(2 downto 0);
      args_ce0              : out  std_logic;
      args_q0               : in   std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
--      mem_in                : in   std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
--      mem_out               : in   std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);

    -- AXI master internal control signals
      IW_EXEC               : out  std_logic;
      IW_DONE               : in   std_logic;
      IW_ADDR               : out  std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      IW_DATA               : out  std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);

      IR_EXEC               : out  std_logic;
      IR_DONE               : in   std_logic;
      IR_ADDR               : out  std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      IR_DATA               : in   std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0)
    );
  end component;
  
  -- Intermediate signals (Unfortunately, internal signals are fixed in HLS autogenerated code)
  signal ap_start_i       : std_logic;
  signal ap_done_i        : std_logic;
  signal ap_ready_i       : std_logic;
  signal ap_idle_i        : std_logic;
  signal id_i             : std_logic_vector(31 downto 0);
  signal id_i_ex          : std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
  signal id_ap_vld_i      : std_logic;
  signal args_address0_i  : std_logic_vector(2 downto 0);
  signal args_ce0_i       : std_logic;
  signal args_q0_i        : std_logic_vector(31 downto 0);
  signal args_q0_i_ex     : std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
--  signal mem_in_i         : std_logic_vector(31 downto 0);
--  signal mem_out_i        : std_logic_vector(31 downto 0);
  
  signal iw_exec_i        : std_logic;
  signal iw_done_i        : std_logic;
  signal iw_addr_i        : std_logic_vector(C_M00_AXI_ADDR_WIDTH-1 downto 0);
  signal iw_data_i        : std_logic_vector(C_M00_AXI_DATA_WIDTH-1 downto 0);

  signal ir_exec_i        : std_logic;
  signal ir_done_i        : std_logic;
  signal ir_addr_i        : std_logic_vector(C_M00_AXI_ADDR_WIDTH-1 downto 0);
  signal ir_data_i        : std_logic_vector(C_M00_AXI_DATA_WIDTH-1 downto 0);
  
  -- HLS quirks
  signal ap_rst_n_inv     : std_logic;

begin

  -- HLS quirks
  ap_rst_n_inv <= not(ap_rst_n);
  id_i_ex <= std_logic_vector(resize(unsigned(id_i), id_i_ex'length));
  args_q0_i_ex <= std_logic_vector(resize(unsigned(args_q0_i), args_q0_i_ex'length));

-- Instantiation of Axi Bus Interface S00_AXI
slave_axi : fred_mod_ctrl_bus_s_axi
	generic map (
		C_S_AXI_DATA_WIDTH	=> C_S00_AXI_DATA_WIDTH,
		C_S_AXI_ADDR_WIDTH	=> C_S00_AXI_ADDR_WIDTH
	)
	port map (
		ACLK	=> ap_clk,
		ARESET 	=> ap_rst_n_inv,
		AWADDR	=> s_axi_ctrl_bus_awaddr,
		--AWPROT	=> s_axi_ctrl_bus_awprot,
		AWVALID	=> s_axi_ctrl_bus_awvalid,
		AWREADY	=> s_axi_ctrl_bus_awready,
		WDATA	=> s_axi_ctrl_bus_wdata,
		WSTRB	=> s_axi_ctrl_bus_wstrb,
		WVALID	=> s_axi_ctrl_bus_wvalid,
		WREADY	=> s_axi_ctrl_bus_wready,
		BRESP	=> s_axi_ctrl_bus_bresp,
		BVALID	=> s_axi_ctrl_bus_bvalid,
		BREADY	=> s_axi_ctrl_bus_bready,
		ARADDR	=> s_axi_ctrl_bus_araddr,
		--ARPROT	=> s_axi_ctrl_bus_arprot,
		ARVALID	=> s_axi_ctrl_bus_arvalid,
		ARREADY	=> s_axi_ctrl_bus_arready,
		RDATA	=> s_axi_ctrl_bus_rdata,
		RRESP	=> s_axi_ctrl_bus_rresp,
		RVALID	=> s_axi_ctrl_bus_rvalid,
		RREADY	=> s_axi_ctrl_bus_rready,
		
		ACLK_EN => '1',
    
        ap_start => ap_start_i,
        ap_done => ap_done_i,
        ap_ready => ap_ready_i,
        ap_idle => ap_idle_i,
        id => id_i,
        id_ap_vld => id_ap_vld_i,
        args_address0 => args_address0_i,
        args_ce0 => args_ce0_i,
        args_q0 => args_q0_i,
        mem_in => open,
        mem_out => open,
        
        interrupt => interrupt
	);

-- Instantiation of Axi Bus Interface M00_AXI
master_axi : fred_mod_lite_v1_0_M00_AXI
	generic map (
		C_M_AXI_ADDR_WIDTH	=> C_M00_AXI_ADDR_WIDTH,
		C_M_AXI_DATA_WIDTH	=> C_M00_AXI_DATA_WIDTH
	)
	port map (
    IW_EXEC => iw_exec_i,
    IW_DONE => iw_done_i,
    IW_ADDR => iw_addr_i,
    IW_DATA => iw_data_i,

    IR_EXEC => ir_exec_i,
    IR_DONE => ir_done_i,
    IR_ADDR => ir_addr_i,
    IR_DATA => ir_data_i,

    M_AXI_ACLK => ap_clk,
    M_AXI_ARESETN => ap_rst_n,
    M_AXI_AWADDR => m_axi_mem_bus_awaddr,
    M_AXI_AWPROT => m_axi_mem_bus_awprot,
    M_AXI_AWVALID => m_axi_mem_bus_awvalid,
    M_AXI_AWREADY => m_axi_mem_bus_awready,
    M_AXI_WDATA	=> m_axi_mem_bus_wdata,
    M_AXI_WSTRB	=> m_axi_mem_bus_wstrb,
    M_AXI_WVALID => m_axi_mem_bus_wvalid,
    M_AXI_WREADY => m_axi_mem_bus_wready,
    M_AXI_BRESP	=> m_axi_mem_bus_bresp,
    M_AXI_BVALID => m_axi_mem_bus_bvalid,
    M_AXI_BREADY => m_axi_mem_bus_bready,
    M_AXI_ARADDR => m_axi_mem_bus_araddr,
    M_AXI_ARPROT => m_axi_mem_bus_arprot,
    M_AXI_ARVALID => m_axi_mem_bus_arvalid,
    M_AXI_ARREADY => m_axi_mem_bus_arready,
    M_AXI_RDATA => m_axi_mem_bus_rdata,
    M_AXI_RRESP => m_axi_mem_bus_rresp,
    M_AXI_RVALID => m_axi_mem_bus_rvalid,
    M_AXI_RREADY => m_axi_mem_bus_rready
	);

core : fred_mod_lite_v1_0_core
  generic map (
    C_S_AXI_ADDR_WIDTH => C_S00_AXI_ADDR_WIDTH,
    C_S_AXI_DATA_WIDTH => C_S00_AXI_DATA_WIDTH,
    C_M_AXI_ADDR_WIDTH => C_M00_AXI_ADDR_WIDTH,
    C_M_AXI_DATA_WIDTH => C_M00_AXI_DATA_WIDTH
  )
  
  port map (
    aclk => ap_clk,
    aresetn => ap_rst_n,

    ap_start => ap_start_i,
    ap_done => ap_done_i,
    ap_ready => ap_ready_i,
    ap_idle => ap_idle_i,
    id => id_i_ex,
    id_ap_vld => id_ap_vld_i,
    args_address0 => args_address0_i,
    args_ce0 => args_ce0_i,
    args_q0 => args_q0_i_ex,
    --mem_in => mem_in_i,
    --mem_out => mem_out_i,

    IW_EXEC => iw_exec_i,
    IW_DONE => iw_done_i,
    IW_ADDR => iw_addr_i,
    IW_DATA => iw_data_i,

    IR_EXEC => ir_exec_i,
    IR_DONE => ir_done_i,
    IR_ADDR => ir_addr_i,
    IR_DATA => ir_data_i
  );

end arch_imp;
