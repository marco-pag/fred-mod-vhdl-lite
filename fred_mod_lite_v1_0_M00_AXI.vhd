-------------------------------------------------------------------------------
--
-- Fred for Linux. Experimental support.
-- VHDL AXI lite stub for HLS-like Fred modules
-- AXI master lite original stub generated by IP integrator
-- 
-------------------------------------------------------------------------------
-- 
-- Copyright (C) 2019, Marco Pagani, ReTiS Lab.
-- <marco.pag(at)outlook.com>
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fred_mod_lite_v1_0_M00_AXI is
  generic (
    C_M_AXI_ADDR_WIDTH  : integer := 32;
    C_M_AXI_DATA_WIDTH  : integer := 32
  );
  port (
    IW_EXEC : in std_logic;
    IW_DONE : out std_logic;
    IW_ADDR  : in std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    IW_DATA  : in std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);

    IR_EXEC : in std_logic;
    IR_DONE : out std_logic;
    IR_ADDR  : in std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    IR_DATA  : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);

    M_AXI_ACLK  : in std_logic;
    M_AXI_ARESETN : in std_logic;
    M_AXI_AWADDR  : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_AWPROT  : out std_logic_vector(2 downto 0);
    M_AXI_AWVALID : out std_logic;
    M_AXI_AWREADY : in std_logic;
    M_AXI_WDATA : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_WSTRB : out std_logic_vector(C_M_AXI_DATA_WIDTH/8-1 downto 0);
    M_AXI_WVALID  : out std_logic;
    M_AXI_WREADY  : in std_logic;
    M_AXI_BRESP : in std_logic_vector(1 downto 0);
    M_AXI_BVALID  : in std_logic;
    M_AXI_BREADY  : out std_logic;
    M_AXI_ARADDR  : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_ARPROT  : out std_logic_vector(2 downto 0);
    M_AXI_ARVALID : out std_logic;
    M_AXI_ARREADY : in std_logic;
    M_AXI_RDATA : in std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_RRESP : in std_logic_vector(1 downto 0);
    M_AXI_RVALID  : in std_logic;
    M_AXI_RREADY  : out std_logic
  );
end fred_mod_lite_v1_0_M00_AXI;

architecture implementation of fred_mod_lite_v1_0_M00_AXI is                                                                 

  -- AXI4LITE signals
  --write address valid
  signal axi_awvalid  : std_logic;
  --write data valid
  signal axi_wvalid : std_logic;
  --read address valid
  signal axi_arvalid  : std_logic;
  --read data acceptance
  signal axi_rready : std_logic;
  --write response acceptance
  signal axi_bready : std_logic;
  --write address
  signal axi_awaddr : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
  --write data
  signal axi_wdata  : std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
  --read addresss
  signal axi_araddr : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
  --Asserts when there is a write response error
  signal write_resp_error : std_logic;
  --Asserts when there is a read response error
  signal read_resp_error  : std_logic;

  signal iw_busy : std_logic;
  signal ir_busy : std_logic;

  signal w_done : std_logic;
  signal r_done : std_logic;
  
  signal r_data : std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);

  type r_state_t is (R_IDLE, R_BUSY);
  type w_state_t is (W_IDLE, W_BUSY);
  
  signal r_state : r_state_t;
  signal w_state : w_state_t;

begin
  -- I/O Connections assignments

  --Adding the offset address to the base addr of the slave
  M_AXI_AWADDR <= axi_awaddr;
  --AXI 4 write data
  M_AXI_WDATA     <= axi_wdata;
  M_AXI_AWPROT  <= "000";
  M_AXI_AWVALID <= axi_awvalid;
  --Write Data(W)
  M_AXI_WVALID  <= axi_wvalid;
  --Set all byte strobes in this example
  M_AXI_WSTRB <= "1111";
  --Write Response (B)
  M_AXI_BREADY  <= axi_bready;
  --Read Address (AR)
    M_AXI_ARADDR  <= axi_araddr;
  M_AXI_ARVALID <= axi_arvalid;
  M_AXI_ARPROT  <= "001";
  --Read and Read Response (R)
  M_AXI_RREADY  <= axi_rready;

  IW_DONE <= w_done;
  IR_DONE <= r_done;
  
  IR_DATA <= r_data;

  ----------------------
  --Write Address Channel
  ----------------------

  -- The purpose of the write address channel is to request the address and 
  -- command information for the entire transaction.  It is a single beat
  -- of information.

  -- Note for this example the axi_awvalid/axi_wvalid are asserted at the same
  -- time, and then each is deasserted independent from each other.
  -- This is a lower-performance, but simplier control scheme.

  -- AXI VALID signals must be held active until accepted by the partner.

  -- A data transfer is accepted by the slave when a master has
  -- VALID data and the slave acknoledges it is also READY. While the master
  -- is allowed to generated multiple, back-to-back requests by not 
  -- deasserting VALID, this design will add rest cycle for
  -- simplicity.

  -- Since only one outstanding transaction is issued by the user design,
  -- there will not be a collision between a new request and an accepted
  -- request on the same clock cycle. 

  process(M_AXI_ACLK)                                                          
  begin                                                                             
    if (rising_edge (M_AXI_ACLK)) then                                              
      --Only VALID signals must be deasserted during reset per AXI spec             
      --Consider inverting then registering active-low reset for higher fmax        
      if (M_AXI_ARESETN = '0') then                                                
        axi_awvalid <= '0';                                                         
      else                                                                          
        --Signal a new address/data command is available by user logic
        if (iw_busy = '0' and IW_EXEC = '1') then                                          
          axi_awvalid <= '1';                                                       
        elsif (M_AXI_AWREADY = '1' and axi_awvalid = '1') then                      
          --Address accepted by interconnect/slave (issue of M_AXI_AWREADY by slave)
          axi_awvalid <= '0';                                                       
        end if;                                                                     
      end if;                                                                       
    end if;                                                                         
  end process;                                                                      


  ----------------------
  --Write Data Channel
  ----------------------

  --The write data channel is for transfering the actual data.
  --The data generation is speific to the example design, and 
  --so only the WVALID/WREADY handshake is shown here

  process(M_AXI_ACLK)                                                 
  begin                                                                         
   if (rising_edge (M_AXI_ACLK)) then                                          
     if (M_AXI_ARESETN = '0') then                                            
       axi_wvalid <= '0';                                                      
     else                                                                      
       if (iw_busy = '0' and IW_EXEC = '1') then                                      
         --Signal a new address/data command is available by user logic        
         axi_wvalid <= '1';                                                    
       elsif (M_AXI_WREADY = '1' and axi_wvalid = '1') then                    
         --Data accepted by interconnect/slave (issue of M_AXI_WREADY by slave)
         axi_wvalid <= '0';                                                    
       end if;                                                                 
     end if;                                                                   
   end if;                                                                     
  end process;                                                                  


  ------------------------------
  --Write Response (B) Channel
  ------------------------------

  --The write response channel provides feedback that the write has committed
  --to memory. BREADY will occur after both the data and the write address
  --has arrived and been accepted by the slave, and can guarantee that no
  --other accesses launched afterwards will be able to be reordered before it.

  --The BRESP bit [1] is used indicate any errors from the interconnect or
  --slave for the entire write burst. This example will capture the error.

  --While not necessary per spec, it is advisable to reset READY signals in
  --case of differing reset latencies between master/slave.

  process(M_AXI_ACLK)                                            
  begin                                                                
    if (rising_edge (M_AXI_ACLK)) then                                 
      if (M_AXI_ARESETN = '0') then                                   
        axi_bready <= '0';                                             
      else                                                             
        if (M_AXI_BVALID = '1' and axi_bready = '0') then              
          -- accept/acknowledge bresp with axi_bready by the master    
          -- when M_AXI_BVALID is asserted by slave                    
           axi_bready <= '1';                                          
        elsif (axi_bready = '1') then                                  
          -- deassert after one clock cycle                            
          axi_bready <= '0';                                           
        end if;                                                        
      end if;                                                          
    end if;                                                            
  end process;                                                         
--Flag write errors                                                    
  write_resp_error <= (axi_bready and M_AXI_BVALID and M_AXI_BRESP(1));


  ------------------------------
  --Read Address Channel
  ------------------------------                                                                 
  
  -- A new axi_arvalid is asserted when there is a valid read address              
  -- available by the master. start_single_read triggers a new read                
  -- transaction                                                                   
  process(M_AXI_ACLK)                                                              
  begin                                                                            
    if (rising_edge (M_AXI_ACLK)) then                                             
      if (M_AXI_ARESETN = '0') then                                               
        axi_arvalid <= '0';                                                        
      else                                                                         
        if (ir_busy = '0' and IR_EXEC = '1') then                                          
          --Signal a new read address command is available by user logic           
          axi_arvalid <= '1';                                                      
        elsif (M_AXI_ARREADY = '1' and axi_arvalid = '1') then                     
        --RAddress accepted by interconnect/slave (issue of M_AXI_ARREADY by slave)
          axi_arvalid <= '0';                                                      
        end if;                                                                    
      end if;                                                                      
    end if;                                                                        
  end process;                                                                     


  ----------------------------------
  --Read Data (and Response) Channel
  ----------------------------------

  --The Read Data channel returns the results of the read request 
  --The master will accept the read data by asserting axi_rready
  --when there is a valid read data available.
  --While not necessary per spec, it is advisable to reset READY signals in
  --case of differing reset latencies between master/slave.
  process(M_AXI_ACLK)                                             
  begin                                                                 
    if (rising_edge (M_AXI_ACLK)) then                                  
      if (M_AXI_ARESETN = '0') then                                    
        axi_rready <= '1';                                              
      else                                                              
        if (M_AXI_RVALID = '1' and axi_rready = '0') then               
         -- accept/acknowledge rdata/rresp with axi_rready by the master
         -- when M_AXI_RVALID is asserted by slave                      
          axi_rready <= '1';                                            
        elsif (axi_rready = '1') then                                   
          -- deassert after one clock cycle                             
          axi_rready <= '0';                                            
        end if;                                                         
      end if;                                                           
    end if;                                                             
  end process;                                                          

  --Flag write errors                                                     
  read_resp_error <= (axi_rready and M_AXI_RVALID and M_AXI_RRESP(1));  


  ----------------------------------
  
  
  write_ctrl : process(M_AXI_ACLK)
  begin
    if (rising_edge (M_AXI_ACLK)) then
     if (M_AXI_ARESETN = '0') then
       w_state <= W_IDLE;
       w_done <= '0';
       iw_busy <= '0';
     else
       case w_state is
         when W_IDLE =>
           w_done <= '0';
           if (IW_EXEC = '1') then
             -- prepare data on the bus
             axi_awaddr <= IW_ADDR;
             axi_wdata <= IW_DATA;
             iw_busy <= '1';
             w_state <= W_BUSY;
           end if;
         when W_BUSY =>
           if (M_AXI_WREADY = '1' and axi_wvalid = '1') then
             -- data accepted by interconnect/slave (issue of M_AXI_WREADY by slave)
             w_done <= '1';
             iw_busy <= '0';
             w_state <= W_IDLE;
           end if;
       end case;
     end if;
    end if;
  end process;

 
  read_ctrl : process(M_AXI_ACLK)
  begin
    if (rising_edge (M_AXI_ACLK)) then
      if (M_AXI_ARESETN = '0') then
        r_state <= R_IDLE;
        r_done <= '0';
        ir_busy <= '0';
      else
      case r_state is
        when R_IDLE =>
          r_done <= '0';
          if (IR_EXEC = '1') then
            -- send a read request on the bus
            ir_busy <= '1';
            axi_araddr <= IR_ADDR;
            r_state <= R_BUSY;
          end if;
        when R_BUSY =>
          if (M_AXI_RVALID = '1' and axi_rready = '1') then
            -- data received
            r_done <= '1';
            ir_busy <= '0';
            r_data <= M_AXI_RDATA;
            -- data accepted by interconnect/slave (issue of M_AXI_WREADY by slave)
            r_state <= R_IDLE;
         end if;
        end case;
      end if;
    end if;
  end process;


end implementation;
